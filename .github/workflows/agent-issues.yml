# Runs every minute: triages open issues and triggers agent work.
# Also run manually from Actions tab via "Run workflow".

name: Agent â€“ Issue handling

on:
  schedule:
    # Every minute
    - cron: '* * * * *'
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  process-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Triage and run agent on open issues
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const octokit = github.rest;

            // Open issues without agent-done, oldest first
            const { data: issues } = await octokit.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              sort: 'created',
              direction: 'asc',
              per_page: 20,
            });

            const labelNames = (issue) => (issue.labels || []).map((l) => l.name);
            const has = (issue, name) => labelNames(issue).includes(name);

            for (const issue of issues) {
              if (issue.pull_request) continue; // skip PRs
              if (has(issue, 'agent-done')) continue;

              const body = (issue.body || '').trim();
              const bodyLong = body.length >= 80;
              const hasNeedsDetails = has(issue, 'needs-details');
              const hasAck = has(issue, 'agent-acknowledged');
              const hasInProgress = has(issue, 'agent-in-progress');

              // 1) Needs more detail: short body and not yet asked
              if (!bodyLong && !hasNeedsDetails) {
                await octokit.issues.addLabels({ owner, repo, issue_number: issue.number, labels: ['needs-details'] });
                await octokit.issues.createComment({
                  owner, repo, issue_number: issue.number,
                  body: `ðŸ‘‹ Thanks for opening this issue. To help the agent implement it, please add a bit more detail:\n\n` +
                    `- **Bug:** Steps to reproduce, expected vs actual behavior, and environment (browser/OS).\n` +
                    `- **Feature:** What you want to see, where it should appear (e.g. HUD, new building type), and any constraints.\n\n` +
                    `Reply here with the details and we'll pick it up.`,
                });
                console.log(`Issue #${issue.number}: added needs-details`);
                return; // one action per run
              }

              // 2) Check if needs-details was satisfied by a comment
              if (hasNeedsDetails) {
                const { data: comments } = await octokit.issues.listComments({ owner, repo, issue_number: issue.number });
                const lastUserComment = comments.filter(c => !c.user?.login?.includes('[bot]')).pop();
                const commentBody = (lastUserComment?.body || '').trim();
                if (commentBody.length >= 40) {
                  await octokit.issues.removeLabel({ owner, repo, issue_number: issue.number, name: 'needs-details' });
                  await octokit.issues.addLabels({ owner, repo, issue_number: issue.number, labels: ['agent-acknowledged'] });
                  await octokit.issues.createComment({
                    owner, repo, issue_number: issue.number,
                    body: `âœ… **Thanks for the details.** The agent will work on this. You'll get another update when work has started and when it's done.`,
                  });
                  console.log(`Issue #${issue.number}: acknowledged after comment`);
                  return;
                }
                return; // still waiting for details
              }

              // 3) Acknowledge: long body, not yet acknowledged
              if (bodyLong && !hasAck) {
                await octokit.issues.addLabels({ owner, repo, issue_number: issue.number, labels: ['agent-acknowledged'] });
                await octokit.issues.createComment({
                  owner, repo, issue_number: issue.number,
                  body: `âœ… **Acknowledged.** The agent will work on this. You'll get another update when work has started and when it's done.`,
                });
                console.log(`Issue #${issue.number}: acknowledged`);
                return;
              }

              // 4) Run agent work: acknowledged and not yet in progress or done
              if (hasAck && !hasInProgress && !has(issue, 'agent-done')) {
                await octokit.issues.addLabels({ owner, repo, issue_number: issue.number, labels: ['agent-in-progress'] });
                await octokit.issues.createComment({
                  owner, repo, issue_number: issue.number,
                  body: `ðŸ”§ **Working on this.** The agent is processing the issue. You'll get a follow-up when a PR is ready or the task is done.`,
                });

                // Placeholder: replace with a step that creates a branch/PR or calls your agent API.
                console.log(`Issue #${issue.number}: agent work (placeholder â€“ replace with real agent step)`);

                await octokit.issues.createComment({
                  owner, repo, issue_number: issue.number,
                  body: `âœ… **Ticket handled.** When you wire the agent step to create a real PR, this comment will link it (e.g. "Done in PR #123").`,
                });
                await octokit.issues.removeLabel({ owner, repo, issue_number: issue.number, name: 'agent-in-progress' });
                await octokit.issues.addLabels({ owner, repo, issue_number: issue.number, labels: ['agent-done'] });
                console.log(`Issue #${issue.number}: marked done`);
                return;
              }
            }
            console.log('No issue needed an action this run.');
